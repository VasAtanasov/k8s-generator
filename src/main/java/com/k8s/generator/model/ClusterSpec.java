package com.k8s.generator.model;

import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import lombok.Builder;

import java.util.List;
import java.util.Objects;

/**
 * Immutable cluster specification - the core domain model.
 *
 * <p>Represents a complete Kubernetes cluster configuration including:
 * <ul>
 *   <li>Cluster metadata (name, type/engine)</li>
 *   <li>Node topology (master count, worker count)</li>
 *   <li>Network configuration (IP allocation)</li>
 *   <li>VM configurations (size profile, custom resources)</li>
 * </ul>
 *
 * <p>Validation Strategy (Three-Layer):
 * <ol>
 *   <li><b>Structural</b>: Enforced in this compact constructor
 *       <br>- Non-null fields, positive counts, basic invariants</li>
 *   <li><b>Semantic</b>: Enforced by SemanticValidator
 *       <br>- Cluster name format, engine-specific rules, IP format validation</li>
 *   <li><b>Policy</b>: Enforced by PolicyValidator
 *       <br>- Cross-cluster constraints, IP overlaps, resource limits</li>
 * </ol>
 *
 * <p>Cluster Types and Node Requirements:
 * <ul>
 *   <li><b>KIND</b>: masters=0, workers=0 (VMs generated as "cluster" role), CNI not required</li>
 *   <li><b>MINIKUBE</b>: masters=0, workers=0 (VMs generated as "cluster" role), CNI not required</li>
 *   <li><b>KUBEADM</b>: masters≥1, workers≥0 (full multi-node cluster), CNI required</li>
 *   <li><b>NONE</b>: masters=0, workers=0 (VMs generated as "management" role), CNI not allowed</li>
 * </ul>
 *
 * <p>IP Allocation:
 * <ul>
 *   <li><b>Single cluster</b>: firstIp nullable (null uses default 192.168.56.10)</li>
 *   <li><b>Multi-cluster</b>: firstIp should be specified for each cluster (prevents overlaps)</li>
 * </ul>
 *
 * <p>Example Usage:
 * <pre>{@code
 * // Simple kind cluster (CLI convention) - using builder
 * var kindCluster = ClusterSpec.builder()
 *     .name("clu-m1-pt-kind")
 *     .type(ClusterType.KIND)
 *     .firstIp((IPAddress) null)  // Use default IP
 *     .masters(0)                 // KIND uses "cluster" role
 *     .workers(0)
 *     .sizeProfile(SizeProfile.MEDIUM)
 *     .vms(List.of())             // VMs generated by orchestrator
 *     .cni(null)                  // No CNI for KIND (uses bundled CNI)
 *     .podNetwork((NetworkCIDR) null)
 *     .svcNetwork((NetworkCIDR) null)
 *     .build();
 *
 * // Multi-node kubeadm cluster with Calico CNI - using builder
 * var kubeadmCluster = ClusterSpec.builder()
 *     .name("clu-m7-exam-kubeadm")
 *     .type(ClusterType.KUBEADM)
 *     .firstIp("192.168.56.20")
 *     .masters(3)                 // 3 masters (HA control plane)
 *     .workers(5)
 *     .sizeProfile(SizeProfile.LARGE)
 *     .vms(List.of(
 *         new VmConfig(VmName.of("clu-m7-exam-kubeadm-master-1"), NodeRole.MASTER, "192.168.56.20", SizeProfile.LARGE),
 *         new VmConfig(VmName.of("clu-m7-exam-kubeadm-master-2"), NodeRole.MASTER, "192.168.56.21", SizeProfile.LARGE)
 *         // ... more VMs
 *     ))
 *     .cni(CniType.CALICO)
 *     .podNetwork("10.244.0.0/16")
 *     .svcNetwork("10.96.0.0/12")
 *     .build();
 * }</pre>
 *
 * @param name        Cluster name (must match [a-z][a-z0-9-]*, validated by SemanticValidator)
 * @param type        Cluster engine type (kind, minikube, kubeadm, none)
 * @param firstIp     Starting IP for sequential allocation (null uses default 192.168.56.10)
 * @param masters     Number of master nodes (0 for kind/minikube/none, 1+ for kubeadm)
 * @param workers     Number of worker nodes (0+ for kubeadm, 0 for kind/minikube/none)
 * @param sizeProfile Default size profile for all VMs in this cluster
 * @param vms         Explicit VM configurations (empty = orchestrator generates from masters/workers)
 * @param cni         CNI plugin type (null for KIND/MINIKUBE/NONE, required for KUBEADM)
 * @param podNetwork  Pod network CIDR (null uses default 10.244.0.0/16 for kubeadm)
 * @param svcNetwork  Service network CIDR (null uses default 10.96.0.0/12 for kubeadm)
 * @see ClusterType
 * @see VmConfig
 * @see SizeProfile
 * @see CniType
 * @see com.k8s.generator.validate.CompositeValidator
 * @since 1.0.0
 */
@Builder(toBuilder = true)
public record ClusterSpec(
        ClusterName name,
        ClusterType type,
        IPAddress firstIp,
        int masters,
        int workers,
        SizeProfile sizeProfile,
        List<VmConfig> vms,
        CniType cni,
        NetworkCIDR podNetwork,
        NetworkCIDR svcNetwork) {
    /**
     * Compact constructor with structural validation.
     *
     * <p>Validates:
     * <ul>
     *   <li>Required fields (name, type, sizeProfile, vms) are non-null</li>
     *   <li>Name is non-blank</li>
     *   <li>Master and worker counts are non-negative</li>
     *   <li>At least one node exists (masters + workers > 0 OR type allows zero nodes)</li>
     *   <li>VMs list contains no nulls</li>
     *   <li>Optional fields (firstIp, cni, podNetwork, svcNetwork) may be null</li>
     * </ul>
     *
     * <p>Note: This constructor does NOT validate:
     * <ul>
     *   <li>Cluster name format (handled by SemanticValidator)</li>
     *   <li>Engine-specific node requirements (handled by SemanticValidator)</li>
     *   <li>IP format and overlaps (handled by SemanticValidator/PolicyValidator)</li>
     *   <li>CNI requirements per cluster type (handled by PolicyValidator)</li>
     * </ul>
     *
     * @throws IllegalArgumentException if any structural validation fails
     */
    public ClusterSpec {
        // Null checks for required fields
        Objects.requireNonNull(name, "name is required");
        Objects.requireNonNull(type, "type is required");
        Objects.requireNonNull(sizeProfile, "sizeProfile is required");
        Objects.requireNonNull(vms, "vms list is required (use List.of() for empty)");
        // firstIp, cni, podNetwork, svcNetwork are nullable (null means "use defaults")

        // Blank check (redundant if ClusterName already enforces non-blank, kept defensive)
        if (name.value().isBlank()) {
            throw new IllegalArgumentException("name cannot be blank");
        }

        // Count validation
        if (masters < 0) {
            throw new IllegalArgumentException("masters must be >= 0, got: " + masters);
        }
        if (workers < 0) {
            throw new IllegalArgumentException("workers must be >= 0, got: " + workers);
        }

        // At least one node required for KUBEADM
        // (KIND/MINIKUBE/NONE allow zero masters+workers, they use "cluster"/"management" role)
        if (type == ClusterType.KUBEADM && masters == 0 && workers == 0) {
            throw new IllegalArgumentException(
                    "KUBEADM cluster requires at least one node (masters + workers > 0)"
            );
        }

        // VMs list must not contain nulls
        if (vms.stream().anyMatch(Objects::isNull)) {
            throw new IllegalArgumentException("vms list contains null elements");
        }

        // Make defensive copy to ensure immutability
        vms = List.copyOf(vms);
    }

    public static class ClusterSpecBuilder {
        public ClusterSpecBuilder name(ClusterName name) {
            this.name = name;
            return this;
        }

        public ClusterSpecBuilder name(String name) {
            this.name = ClusterName.of(name);
            return this;
        }

        // typed setter for firstIp(IPAddress) is generated by Lombok; keep only String overload here

        /**
         * Convenience method to set firstIp from string.
         * Uses IPAddressString library for parsing and validation.
         *
         * @param ipString IP address string (e.g., "192.168.56.10"), or null
         * @return this builder
         * @throws IllegalArgumentException if IP format is invalid
         */
        public ClusterSpecBuilder firstIp(String ipString) {
            if (ipString == null || ipString.isBlank()) {
                this.firstIp = null;
                return this;
            }

            // Use strict parsing to avoid inet_aton-style permissive formats
            IPAddressStringParameters params = new IPAddressStringParameters.Builder()
                    .allow_inet_aton(false)
                    .toParams();
            IPAddressString ipAddr = new IPAddressString(ipString, params);
            if (!ipAddr.isValid()) {
                throw new IllegalArgumentException("Invalid IP address format: " + ipString);
            }

            this.firstIp = ipAddr.getAddress();
            return this;
        }

        /**
         * Convenience method to set firstIp from string.
         * Uses IPAddressString library for parsing and validation.
         *
         * @param ipString IP address string (e.g., "192.168.56.10"), or null
         * @return this builder
         * @throws IllegalArgumentException if IP format is invalid
         */
        public ClusterSpecBuilder firstIp(IPAddress ip) {
            this.firstIp = ip;
            return this;
        }

        /**
         * Convenience method to set podNetwork from CIDR string.
         * Uses NetworkCIDR for parsing and validation.
         *
         * @param cidr CIDR notation string (e.g., "10.244.0.0/16"), or null
         * @return this builder
         * @throws IllegalArgumentException if CIDR format is invalid
         */
        public ClusterSpecBuilder podNetwork(String cidr) {
            if (cidr == null || cidr.isBlank()) {
                this.podNetwork = null;
                return this;
            }

            this.podNetwork = NetworkCIDR.of(cidr);
            return this;
        }

        public ClusterSpecBuilder podNetwork(NetworkCIDR network) {
            this.podNetwork = network;
            return this;
        }

        /**
         * Convenience method to set svcNetwork from CIDR string.
         * Uses NetworkCIDR for parsing and validation.
         *
         * @param cidr CIDR notation string (e.g., "10.96.0.0/12"), or null
         * @return this builder
         * @throws IllegalArgumentException if CIDR format is invalid
         */
        public ClusterSpecBuilder svcNetwork(String cidr) {
            if (cidr == null || cidr.isBlank()) {
                this.svcNetwork = null;
                return this;
            }

            this.svcNetwork = NetworkCIDR.of(cidr);
            return this;
        }

        public ClusterSpecBuilder svcNetwork(NetworkCIDR network) {
            this.svcNetwork = network;
            return this;
        }
    }

    /**
     * Returns total node count (masters + workers).
     * Note: For KIND/MINIKUBE/NONE, this returns 0, but they generate 1 VM with special role.
     *
     * @return total nodes declared (could be 0 for single-VM engines)
     */
    public int totalNodes() {
        return masters + workers;
    }

    /**
     * Checks if this cluster has explicit VM configurations.
     * Empty list means orchestrator should generate VMs from masters/workers counts.
     *
     * @return true if vms list is not empty
     */
    public boolean hasExplicitVms() {
        return !vms.isEmpty();
    }

    /**
     * Checks if this is a multi-master (HA) cluster.
     *
     * @return true if masters > 1
     */
    public boolean isHighAvailability() {
        return masters > 1;
    }

    /**
     * Returns a new ClusterSpec with updated VMs list.
     * Used by orchestrator to set generated VMs.
     *
     * @param newVms new VMs list (must not be null)
     * @return new ClusterSpec with updated VMs
     * @throws IllegalArgumentException if newVms is null or contains nulls
     */
    public ClusterSpec withVms(List<VmConfig> newVms) {
        Objects.requireNonNull(newVms, "newVms cannot be null");
        return this.toBuilder().vms(newVms).build();
    }

    /**
     * Returns a new ClusterSpec with updated CNI type.
     * Used when applying defaults or overrides.
     *
     * @param newCni new CNI type (can be null)
     * @return new ClusterSpec with updated CNI
     */
    public ClusterSpec withCni(CniType newCni) {
        return this.toBuilder().cni(newCni).build();
    }
}
