package com.k8s.generator.model;

import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * Immutable cluster specification - the core domain model.
 *
 * <p>Represents a complete Kubernetes cluster configuration including:
 * <ul>
 *   <li>Cluster metadata (name, type/engine)</li>
 *   <li>Node topology (master count, worker count)</li>
 *   <li>Network configuration (IP allocation)</li>
 *   <li>VM configurations (size profile, custom resources)</li>
 * </ul>
 *
 * <p>Validation Strategy (Three-Layer):
 * <ol>
 *   <li><b>Structural</b>: Enforced in this compact constructor
 *       <br>- Non-null fields, positive counts, basic invariants</li>
 *   <li><b>Semantic</b>: Enforced by SemanticValidator
 *       <br>- Cluster name format, engine-specific rules, IP format validation</li>
 *   <li><b>Policy</b>: Enforced by PolicyValidator
 *       <br>- Cross-cluster constraints, IP overlaps, resource limits</li>
 * </ol>
 *
 * <p>Cluster Types and Node Requirements:
 * <ul>
 *   <li><b>KIND</b>: masters=0, workers=0 (VMs generated as "cluster" role), CNI not required</li>
 *   <li><b>MINIKUBE</b>: masters=0, workers=0 (VMs generated as "cluster" role), CNI not required</li>
 *   <li><b>KUBEADM</b>: masters≥1, workers≥0 (full multi-node cluster), CNI required</li>
 *   <li><b>NONE</b>: masters=0, workers=0 (VMs generated as "management" role), CNI not allowed</li>
 * </ul>
 *
 * <p>IP Allocation:
 * <ul>
 *   <li><b>Single cluster</b>: firstIp optional (defaults to 192.168.56.10)</li>
 *   <li><b>Multi-cluster</b>: firstIp required for each cluster (prevents overlaps)</li>
 * </ul>
 *
 * <p>Example Usage:
 * <pre>{@code
 * // Simple kind cluster (CLI convention)
 * var kindCluster = new ClusterSpec(
 *     "dev",
 *     ClusterType.KIND,
 *     Optional.empty(),     // Use default IP
 *     0,                    // KIND uses "cluster" role, not masters
 *     0,                    // KIND uses "cluster" role, not workers
 *     SizeProfile.MEDIUM,
 *     List.of(),            // VMs generated by orchestrator
 *     Optional.empty()      // No CNI for KIND (uses bundled CNI)
 * );
 *
 * // Multi-node kubeadm cluster with Calico CNI
 * var kubeadmCluster = new ClusterSpec(
 *     "staging",
 *     ClusterType.KUBEADM,
 *     Optional.of("192.168.56.20"),
 *     3,                    // 3 masters (HA control plane)
 *     5,                    // 5 workers
 *     SizeProfile.LARGE,
 *     List.of(
 *         new VmConfig("master-1", NodeRole.MASTER, "192.168.56.20", SizeProfile.LARGE, Optional.empty(), Optional.empty()),
 *         new VmConfig("master-2", NodeRole.MASTER, "192.168.56.21", SizeProfile.LARGE, Optional.empty(), Optional.empty()),
 *         // ... more VMs
 *     ),
 *     Optional.of(CniType.CALICO)  // CNI required for kubeadm
 * );
 * }</pre>
 *
 * @param name        Cluster name (must match [a-z][a-z0-9-]*, validated by SemanticValidator)
 * @param type        Cluster engine type (kind, minikube, kubeadm, none)
 * @param firstIp     Starting IP for sequential allocation (empty = use default 192.168.56.10)
 * @param masters     Number of master nodes (0 for kind/minikube/none, 1+ for kubeadm)
 * @param workers     Number of worker nodes (0+ for kubeadm, 0 for kind/minikube/none)
 * @param sizeProfile Default size profile for all VMs in this cluster
 * @param vms         Explicit VM configurations (empty = orchestrator generates from masters/workers)
 * @param cni         CNI plugin type (required for KUBEADM, empty for KIND/MINIKUBE/NONE)
 * @see ClusterType
 * @see VmConfig
 * @see SizeProfile
 * @see CniType
 * @see com.k8s.generator.validate.CompositeValidator
 * @since 1.0.0
 */
public record ClusterSpec(
        ClusterName name,
        ClusterType type,
        Optional<String> firstIp,
        int masters,
        int workers,
        SizeProfile sizeProfile,
        List<VmConfig> vms,
        Optional<CniType> cni) {
    /**
     * Compact constructor with structural validation.
     *
     * <p>Validates:
     * <ul>
     *   <li>All required fields are non-null</li>
     *   <li>Name is non-blank</li>
     *   <li>Master and worker counts are non-negative</li>
     *   <li>At least one node exists (masters + workers > 0 OR type allows zero nodes)</li>
     *   <li>VMs list contains no nulls</li>
     *   <li>CNI field is non-null (use Optional.empty() if no CNI)</li>
     * </ul>
     *
     * <p>Note: This constructor does NOT validate:
     * <ul>
     *   <li>Cluster name format (handled by SemanticValidator)</li>
     *   <li>Engine-specific node requirements (handled by SemanticValidator)</li>
     *   <li>IP format and overlaps (handled by SemanticValidator/PolicyValidator)</li>
     *   <li>CNI requirements per cluster type (handled by PolicyValidator)</li>
     * </ul>
     *
     * @throws IllegalArgumentException if any structural validation fails
     */
    public ClusterSpec {
        // Null checks
        Objects.requireNonNull(name, "name is required");
        Objects.requireNonNull(type, "type is required");
        Objects.requireNonNull(firstIp, "firstIp must be present (use Optional.empty())");
        Objects.requireNonNull(sizeProfile, "sizeProfile is required");
        Objects.requireNonNull(vms, "vms list is required (use List.of() for empty)");
        Objects.requireNonNull(cni, "cni must be present (use Optional.empty() if no CNI)");

        // Blank check (redundant if ClusterName already enforces non-blank, kept defensive)
        if (name.value().isBlank()) {
            throw new IllegalArgumentException("name cannot be blank");
        }

        // Count validation
        if (masters < 0) {
            throw new IllegalArgumentException("masters must be >= 0, got: " + masters);
        }
        if (workers < 0) {
            throw new IllegalArgumentException("workers must be >= 0, got: " + workers);
        }

        // At least one node required for KUBEADM
        // (KIND/MINIKUBE/NONE allow zero masters+workers, they use "cluster"/"management" role)
        if (type == ClusterType.KUBEADM && masters == 0 && workers == 0) {
            throw new IllegalArgumentException(
                    "KUBEADM cluster requires at least one node (masters + workers > 0)"
            );
        }

        // VMs list must not contain nulls
        if (vms.stream().anyMatch(Objects::isNull)) {
            throw new IllegalArgumentException("vms list contains null elements");
        }

        // Make defensive copy to ensure immutability
        vms = List.copyOf(vms);
    }

    /**
     * Returns total node count (masters + workers).
     * Note: For KIND/MINIKUBE/NONE, this returns 0, but they generate 1 VM with special role.
     *
     * @return total nodes declared (may be 0 for single-VM engines)
     */
    public int totalNodes() {
        return masters + workers;
    }

    /**
     * Checks if this cluster has explicit VM configurations.
     * Empty list means orchestrator should generate VMs from masters/workers counts.
     *
     * @return true if vms list is not empty
     */
    public boolean hasExplicitVms() {
        return !vms.isEmpty();
    }

    /**
     * Checks if this is a multi-master (HA) cluster.
     *
     * @return true if masters > 1
     */
    public boolean isHighAvailability() {
        return masters > 1;
    }

    /**
     * Returns a new ClusterSpec with updated VMs list.
     * Used by orchestrator to set generated VMs.
     *
     * @param newVms new VMs list (must not be null)
     * @return new ClusterSpec with updated VMs
     * @throws IllegalArgumentException if newVms is null or contains nulls
     */
    public ClusterSpec withVms(List<VmConfig> newVms) {
        Objects.requireNonNull(newVms, "newVms cannot be null");
        return new ClusterSpec(name, type, firstIp, masters, workers, sizeProfile, newVms, cni);
    }

    /**
     * Returns a new ClusterSpec with updated CNI type.
     * Used when applying defaults or overrides.
     *
     * @param newCni new CNI type (must not be null)
     * @return new ClusterSpec with updated CNI
     * @throws IllegalArgumentException if newCni is null
     */
    public ClusterSpec withCni(Optional<CniType> newCni) {
        Objects.requireNonNull(newCni, "newCni cannot be null");
        return new ClusterSpec(name, type, firstIp, masters, workers, sizeProfile, vms, newCni);
    }
}
