package com.k8s.generator.parser;

import com.k8s.generator.cli.GenerateCommand;
import com.k8s.generator.model.*;

import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

/**
 * Converts CLI arguments to GeneratorSpec with convention-over-configuration defaults.
 *
 * <p>This implementation applies the following conventions:
 * <ul>
 *   <li><b>Cluster name</b>: clu-{num}-{type}-{engine} (e.g., "clu-m1-pt-kind")</li>
 *   <li><b>Size profile</b>: MEDIUM (if not specified)</li>
 *   <li><b>IP allocation</b>: Empty (deferred to PlanBuilder)</li>
 *   <li><b>VMs</b>: Empty list (generated by PlanBuilder based on cluster type)</li>
 *   <li><b>Node counts</b>: 0 masters, 0 workers for kind/minikube (single-VM cluster)</li>
 * </ul>
 *
 * <p>Phase 1 MVP Limitations:
 * <ul>
 *   <li>Only supports kind and minikube cluster types</li>
 *   <li>No CLI options for size profiles (hardcoded to MEDIUM)</li>
 *   <li>No CLI options for IP addresses (applied by PlanBuilder)</li>
 *   <li>Always creates single-cluster specs</li>
 * </ul>
 *
 * <p>Error Handling:
 * <ul>
 *   <li>Throws NullPointerException if cmd is null</li>
 *   <li>Throws IllegalArgumentException if cluster type is unsupported in Phase 1</li>
 *   <li>Relies on ModuleInfo and ClusterSpec validation for format checking</li>
 * </ul>
 *
 * <p>Example Usage:
 * <pre>{@code
 * var cmd = new GenerateCommand();
 * cmd.module = "m1";
 * cmd.type = "pt";
 * cmd.clusterType = "kind";
 *
 * var converter = new CliToSpec();
 * GeneratorSpec spec = converter.convert(cmd);
 *
 * // Result:
 * // spec.module() = ModuleInfo("m1", "pt")
 * // spec.clusters().size() = 1
 * // spec.primaryCluster().name() = "clu-m1-pt-kind"
 * // spec.primaryCluster().type() = ClusterType.KIND
 * // spec.primaryCluster().sizeProfile() = SizeProfile.MEDIUM
 * // spec.primaryCluster().masters() = 0
 * // spec.primaryCluster().workers() = 0
 * // spec.primaryCluster().vms() = List.of()
 * }</pre>
 *
 * @see SpecConverter
 * @see GenerateCommand
 * @see GeneratorSpec
 * @since 1.0.0
 */
public final class CliToSpec implements SpecConverter {

    /**
     * Converts CLI command to GeneratorSpec.
     *
     * @param cmd Picocli command object (must not be null)
     * @return GeneratorSpec with defaults applied
     * @throws NullPointerException if cmd is null
     * @throws IllegalArgumentException if cluster type is unsupported or data is invalid
     */
    @Override
    public GeneratorSpec convert(GenerateCommand cmd) {
        Objects.requireNonNull(cmd, "cmd is required");
        Objects.requireNonNull(cmd.module, "cmd.module is required");
        Objects.requireNonNull(cmd.type, "cmd.type is required");
        Objects.requireNonNull(cmd.clusterType, "cmd.clusterType is required");

        // 1. Parse and create ModuleInfo
        // This will throw IllegalArgumentException if format is invalid
        ModuleInfo module = new ModuleInfo(cmd.module, cmd.type);

        // 2. Parse cluster type (kind|minikube|kubeadm|mgmt)
        ClusterType clusterType = parseClusterType(cmd.clusterType);

        // 3. Build cluster name using convention: clu-{num}-{type}-{engine}
        String clusterName = buildClusterName(module, clusterType);

        // 4. Resolve size profile
        SizeProfile sizeProfile = resolveSize(cmd.size);

        // 5. Resolve nodes and CNI based on cluster type
        int masters = 0;
        int workers = 0;
        Optional<CniType> cni = Optional.empty();

        switch (clusterType) {
            case KIND, MINIKUBE -> {
                // Single-node engines: no masters/workers, no CNI
                masters = 0;
                workers = 0;
                cni = Optional.empty();
            }
            case KUBEADM -> {
                int[] nw = parseNodes(cmd.nodes);
                masters = nw[0];
                workers = nw[1];
                cni = parseCni(cmd.cni);
            }
            case NONE -> {
                // Management VM: no nodes, no CNI
                masters = 0;
                workers = 0;
                cni = Optional.empty();
            }
        }

        ClusterSpec cluster = new ClusterSpec(
            clusterName,
            clusterType,
            Optional.empty(),
            masters,
            workers,
            sizeProfile,
            List.of(),
            cni
        );

        // 5. Create single-cluster spec (Phase 1 MVP)
        return new GeneratorSpec(module, List.of(cluster));
    }

    /**
     * Parses cluster type from CLI string.
     *
     * Supports kind, minikube, kubeadm, and mgmt (maps to NONE).
     *
     * @param clusterType cluster type string (case-insensitive)
     * @return ClusterType enum value
     * @throws IllegalArgumentException if cluster type is unsupported in Phase 1
     */
    private ClusterType parseClusterType(String clusterType) {
        String normalized = clusterType.trim().toLowerCase(Locale.ROOT);

        return switch (normalized) {
            case "kind" -> ClusterType.KIND;
            case "minikube" -> ClusterType.MINIKUBE;
            case "kubeadm" -> ClusterType.KUBEADM;
            case "mgmt", "none" -> ClusterType.NONE;
            default -> throw new IllegalArgumentException(
                String.format(
                    "Unsupported cluster type: '%s'. Supported: kind, minikube, kubeadm, mgmt",
                    clusterType
                )
            );
        };
    }

    /**
     * Builds cluster name using convention: clu-{num}-{type}-{engine}.
     *
     * <p>Examples:
     * <ul>
     *   <li>module=m1, type=pt, engine=kind → "clu-m1-pt-kind"</li>
     *   <li>module=m7, type=exam-prep, engine=minikube → "clu-m7-exam-prep-minikube"</li>
     * </ul>
     *
     * @param module module info
     * @param clusterType cluster engine type
     * @return cluster name
     */
    private String buildClusterName(ModuleInfo module, ClusterType clusterType) {
        return String.format(
            "clu-%s-%s-%s",
            module.num(),
            module.type(),
            clusterType.name().toLowerCase(Locale.ROOT)
        );
    }

    private SizeProfile resolveSize(String sizeToken) {
        if (sizeToken == null || sizeToken.isBlank()) return SizeProfile.MEDIUM;
        return SizeProfile.fromString(sizeToken);
    }

    private Optional<CniType> parseCni(String cniToken) {
        if (cniToken == null || cniToken.isBlank()) return Optional.empty();
        try {
            return Optional.of(CniType.valueOf(cniToken.trim().toUpperCase(Locale.ROOT)));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(
                String.format(
                    "Invalid CNI type: '%s'. Valid values: calico, flannel, weave, cilium, antrea",
                    cniToken
                )
            );
        }
    }

    private int[] parseNodes(String nodesToken) {
        // Default: 1 master, 0 workers when unspecified for kubeadm
        if (nodesToken == null || nodesToken.isBlank()) {
            return new int[]{1, 0};
        }

        String s = nodesToken.trim().toLowerCase(Locale.ROOT).replace(" ", "");
        // Pure numeric: N => 1m, (N-1)w (min 0)
        if (s.matches("^\\d+$")) {
            int n = Integer.parseInt(s);
            int masters = 1;
            int workers = Math.max(0, n - 1);
            return new int[]{masters, workers};
        }

        // Pattern Xm,Yw in any order
        int masters = 0;
        int workers = 0;
        for (String part : s.split(",")) {
            if (part.endsWith("m")) {
                masters = Integer.parseInt(part.substring(0, part.length() - 1));
            } else if (part.endsWith("w")) {
                workers = Integer.parseInt(part.substring(0, part.length() - 1));
            } else if (!part.isBlank()) {
                throw new IllegalArgumentException(
                    String.format("Invalid --nodes segment: '%s'. Use N or Xm,Yw (e.g., 1m,2w)", part)
                );
            }
        }
        return new int[]{masters, workers};
    }
}
