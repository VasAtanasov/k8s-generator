package com.k8s.generator.parser;

import com.k8s.generator.cli.GenerateCommand;
import com.k8s.generator.model.*;
import lombok.Builder;

import java.util.List;
import java.util.Locale;
import java.util.Objects;

/**
 * Converts CLI arguments to GeneratorSpec with convention-over-configuration defaults.
 *
 * <p>This implementation applies the following conventions:
 * <ul>
 *   <li><b>Cluster name</b>: clu-{num}-{type}-{engine} (e.g., "clu-m1-pt-kind")</li>
 *   <li><b>Size profile</b>: MEDIUM (if not specified)</li>
 *   <li><b>IP allocation</b>: Empty (deferred to PlanBuilder)</li>
 *   <li><b>VMs</b>: Empty list (generated by PlanBuilder based on cluster type)</li>
 *   <li><b>Node counts</b>: 0 masters, 0 workers for kind/minikube (single-VM cluster)</li>
 * </ul>
 *
 * <p>Phase 1 MVP Limitations:
 * <ul>
 *   <li>Only supports kind and minikube cluster types</li>
 *   <li>No CLI options for size profiles (hardcoded to MEDIUM)</li>
 *   <li>No CLI options for IP addresses (applied by PlanBuilder)</li>
 *   <li>Always creates single-cluster specs</li>
 * </ul>
 *
 * <p>Error Handling:
 * <ul>
 *   <li>Throws NullPointerException if cmd is null</li>
 *   <li>Throws IllegalArgumentException if cluster type is unsupported in Phase 1</li>
 *   <li>Relies on ModuleInfo and ClusterSpec validation for format checking</li>
 * </ul>
 *
 * <p>Example Usage:
 * <pre>{@code
 * var cmd = new GenerateCommand();
 * cmd.module = "m1";
 * cmd.type = "pt";
 * cmd.clusterType = "kind";
 *
 * var converter = new CliToSpec();
 * GeneratorSpec spec = converter.convert(cmd);
 *
 * // Result:
 * // spec.module() = ModuleInfo("m1", "pt")
 * // spec.clusters().size() = 1
 * // spec.primaryCluster().name() = "clu-m1-pt-kind"
 * // spec.primaryCluster().type() = ClusterType.KIND
 * // spec.primaryCluster().sizeProfile() = SizeProfile.MEDIUM
 * // spec.primaryCluster().masters() = 0
 * // spec.primaryCluster().workers() = 0
 * // spec.primaryCluster().vms() = List.of()
 * }</pre>
 *
 * @see SpecConverter
 * @see GenerateCommand
 * @see GeneratorSpec
 * @since 1.0.0
 */
public final class CliToSpec implements SpecConverter {

    /**
     * Converts CLI command to GeneratorSpec.
     *
     * @param cmd Picocli command object (must not be null)
     * @return GeneratorSpec with defaults applied
     * @throws NullPointerException     if cmd is null
     * @throws IllegalArgumentException if cluster type is unsupported or data is invalid
     */
    @Override
    public GeneratorSpec convert(GenerateCommand cmd) {
        Objects.requireNonNull(cmd, "cmd is required");
        Objects.requireNonNull(cmd.module, "cmd.module is required");
        Objects.requireNonNull(cmd.type, "cmd.type is required");
        Objects.requireNonNull(cmd.clusterType, "cmd.clusterType is required");

        // 1. Parse and create ModuleInfo
        // This will throw IllegalArgumentException if format is invalid
        ModuleInfo module = ModuleInfo.of(cmd.module, cmd.type);

        // 2. Parse cluster type (kind|minikube|kubeadm|mgmt)
        ClusterType clusterType = parseClusterType(cmd.clusterType);

        // 3. Build cluster name using convention: clu-{num}-{type}-{engine}
        ClusterName clusterName = buildClusterName(module, clusterType);

        // 4. Resolve size profile
        ClusterSpec cluster = getClusterSpec(cmd, clusterType, clusterName);

        // 5. Create single-cluster spec (Phase 1 MVP)
        return new GeneratorSpec(module, List.of(cluster));
    }

    private ClusterSpec getClusterSpec(final GenerateCommand cmd,
                                       final ClusterType clusterType,
                                       final ClusterName clusterName) {
        SizeProfile sizeProfile = resolveSize(cmd.size);

        // 5. Resolve nodes and CNI based on cluster type
        Spec spec = switch (clusterType) {
            // Single-node engines: no masters/workers, no CNI
            case KIND, MINIKUBE -> Spec.empty();
            case KUBEADM -> {
                int[] nw = parseNodes(cmd.nodes);
                yield Spec.builder()
                        .masters(nw[0])
                        .workers(nw[1])
                        .cni(parseCni(cmd.cni))
                        .build();
            }
            // Management VM: no nodes, no CNI
            case NONE -> Spec.empty();
        };

        return ClusterSpec.builder()
                .name(clusterName)
                .type(clusterType)
                .masters(spec.masters())
                .workers(spec.workers())
                .sizeProfile(sizeProfile)
                .vms(List.of())
                .cni(spec.cni())
                .build();
    }

    @Builder
    private record Spec(int masters, int workers, CniType cni) {
        static Spec empty() {
            return new Spec(0, 0, null);
        }
    }

    /**
     * Parses cluster type from CLI string.
     * <p>
     * Supports kind, minikube, kubeadm, and mgmt (maps to NONE).
     *
     * @param clusterType cluster type string (case-insensitive)
     * @return ClusterType enum value
     * @throws IllegalArgumentException if cluster type is unsupported in Phase 1
     */
    private ClusterType parseClusterType(String clusterType) {
        String normalized = clusterType.trim().toLowerCase(Locale.ROOT);

        return switch (normalized) {
            case "kind" -> ClusterType.KIND;
            case "minikube" -> ClusterType.MINIKUBE;
            case "kubeadm" -> ClusterType.KUBEADM;
            case "mgmt", "none" -> ClusterType.NONE;
            default -> throw new IllegalArgumentException(
                    String.format(
                            "Unsupported cluster type: '%s'. Supported: kind, minikube, kubeadm, mgmt",
                            clusterType
                    )
            );
        };
    }

    /**
     * Builds cluster name using convention: clu-{num}-{type}-{engine}.
     *
     * <p>Examples:
     * <ul>
     *   <li>module=m1, type=pt, engine=kind → "clu-m1-pt-kind"</li>
     *   <li>module=m7, type=exam-prep, engine=minikube → "clu-m7-exam-prep-minikube"</li>
     * </ul>
     *
     * @param module      module info
     * @param clusterType cluster engine type
     * @return cluster name
     */
    private ClusterName buildClusterName(ModuleInfo module, ClusterType clusterType) {
        return ClusterName.of(String.format(
                "clu-%s-%s-%s",
                module.num(),
                module.type(),
                clusterType.name().toLowerCase(Locale.ROOT)
        ));
    }

    private SizeProfile resolveSize(String sizeToken) {
        if (sizeToken == null || sizeToken.isBlank()) return SizeProfile.MEDIUM;
        return SizeProfile.fromString(sizeToken);
    }

    private CniType parseCni(String cniToken) {
        if (cniToken == null || cniToken.isBlank()) return null;
        try {
            return CniType.valueOf(cniToken.trim().toUpperCase(Locale.ROOT));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(
                    String.format(
                            "Invalid CNI type: '%s'. Valid values: calico, flannel, weave, cilium, antrea",
                            cniToken
                    )
            );
        }
    }

    private int[] parseNodes(String nodesToken) {
        // Default: 1 master, 0 workers when unspecified for kubeadm
        if (nodesToken == null || nodesToken.isBlank()) {
            return new int[]{1, 0};
        }

        String s = nodesToken.trim().toLowerCase(Locale.ROOT).replace(" ", "");
        // Pure numeric: N => 1m, (N-1)w (min 0)
        if (s.matches("^\\d+$")) {
            int n = Integer.parseInt(s);
            int masters = 1;
            int workers = Math.max(0, n - 1);
            return new int[]{masters, workers};
        }

        // Pattern Xm,Yw in any order
        int masters = 0;
        int workers = 0;
        for (String part : s.split(",")) {
            if (part.endsWith("m")) {
                masters = parseCount(part);
            } else if (part.endsWith("w")) {
                workers = parseCount(part);
            } else if (!part.isBlank()) {
                throw new IllegalArgumentException(
                        String.format("Invalid --nodes segment: '%s'. Use N or Xm,Yw (e.g., 1m,2w)", part)
                );
            }
        }
        return new int[]{masters, workers};
    }

    private static int parseCount(String part) {
        return Integer.parseInt(part.substring(0, part.length() - 1));
    }
}
