package com.k8s.generator.parser;

import com.k8s.generator.cli.GenerateCommand;
import com.k8s.generator.model.*;

import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

/**
 * Converts CLI arguments to GeneratorSpec with convention-over-configuration defaults.
 *
 * <p>This implementation applies the following conventions:
 * <ul>
 *   <li><b>Cluster name</b>: clu-{num}-{type}-{engine} (e.g., "clu-m1-pt-kind")</li>
 *   <li><b>Size profile</b>: MEDIUM (if not specified)</li>
 *   <li><b>IP allocation</b>: Empty (deferred to PlanBuilder)</li>
 *   <li><b>VMs</b>: Empty list (generated by PlanBuilder based on cluster type)</li>
 *   <li><b>Node counts</b>: 0 masters, 0 workers for kind/minikube (single-VM cluster)</li>
 * </ul>
 *
 * <p>Phase 1 MVP Limitations:
 * <ul>
 *   <li>Only supports kind and minikube cluster types</li>
 *   <li>No CLI options for size profiles (hardcoded to MEDIUM)</li>
 *   <li>No CLI options for IP addresses (applied by PlanBuilder)</li>
 *   <li>Always creates single-cluster specs</li>
 * </ul>
 *
 * <p>Error Handling:
 * <ul>
 *   <li>Throws NullPointerException if cmd is null</li>
 *   <li>Throws IllegalArgumentException if cluster type is unsupported in Phase 1</li>
 *   <li>Relies on ModuleInfo and ClusterSpec validation for format checking</li>
 * </ul>
 *
 * <p>Example Usage:
 * <pre>{@code
 * var cmd = new GenerateCommand();
 * cmd.module = "m1";
 * cmd.type = "pt";
 * cmd.clusterType = "kind";
 *
 * var converter = new CliToSpec();
 * GeneratorSpec spec = converter.convert(cmd);
 *
 * // Result:
 * // spec.module() = ModuleInfo("m1", "pt")
 * // spec.clusters().size() = 1
 * // spec.primaryCluster().name() = "clu-m1-pt-kind"
 * // spec.primaryCluster().type() = ClusterType.KIND
 * // spec.primaryCluster().sizeProfile() = SizeProfile.MEDIUM
 * // spec.primaryCluster().masters() = 0
 * // spec.primaryCluster().workers() = 0
 * // spec.primaryCluster().vms() = List.of()
 * }</pre>
 *
 * @see SpecConverter
 * @see GenerateCommand
 * @see GeneratorSpec
 * @since 1.0.0
 */
public final class CliToSpec implements SpecConverter {

    /**
     * Converts CLI command to GeneratorSpec.
     *
     * @param cmd Picocli command object (must not be null)
     * @return GeneratorSpec with defaults applied
     * @throws NullPointerException if cmd is null
     * @throws IllegalArgumentException if cluster type is unsupported or data is invalid
     */
    @Override
    public GeneratorSpec convert(GenerateCommand cmd) {
        Objects.requireNonNull(cmd, "cmd is required");
        Objects.requireNonNull(cmd.module, "cmd.module is required");
        Objects.requireNonNull(cmd.type, "cmd.type is required");
        Objects.requireNonNull(cmd.clusterType, "cmd.clusterType is required");

        // 1. Parse and create ModuleInfo
        // This will throw IllegalArgumentException if format is invalid
        ModuleInfo module = new ModuleInfo(cmd.module, cmd.type);

        // 2. Parse cluster type (Phase 1: only kind and minikube)
        ClusterType clusterType = parseClusterType(cmd.clusterType);

        // 3. Build cluster name using convention: clu-{num}-{type}-{engine}
        String clusterName = buildClusterName(module, clusterType);

        // 4. Apply defaults for Phase 1 MVP:
        //    - masters=0, workers=0 (for kind/minikube, VM generated by PlanBuilder)
        //    - sizeProfile=MEDIUM
        //    - firstIp=Optional.empty() (IP allocated by PlanBuilder)
        //    - vms=List.of() (VMs generated by PlanBuilder)
        ClusterSpec cluster = new ClusterSpec(
            clusterName,
            clusterType,
            Optional.empty(),           // No explicit IP, use PlanBuilder default
            0,                          // No masters (kind/minikube use CLUSTER role)
            0,                          // No workers (kind/minikube use CLUSTER role)
            SizeProfile.MEDIUM,         // Convention-over-configuration default
            List.of()                   // VMs generated by PlanBuilder
        );

        // 5. Create single-cluster spec (Phase 1 MVP)
        return new GeneratorSpec(module, List.of(cluster));
    }

    /**
     * Parses cluster type from CLI string.
     *
     * <p>Phase 1 MVP: Only kind and minikube supported.
     * Phase 2+: Add kubeadm, mgmt (none).
     *
     * @param clusterType cluster type string (case-insensitive)
     * @return ClusterType enum value
     * @throws IllegalArgumentException if cluster type is unsupported in Phase 1
     */
    private ClusterType parseClusterType(String clusterType) {
        String normalized = clusterType.trim().toLowerCase(Locale.ROOT);

        return switch (normalized) {
            case "kind" -> ClusterType.KIND;
            case "minikube" -> ClusterType.MINIKUBE;
            case "kubeadm" -> throw new IllegalArgumentException(
                "kubeadm cluster type not yet supported in Phase 1 MVP. " +
                "Supported types: kind, minikube"
            );
            case "mgmt", "none" -> throw new IllegalArgumentException(
                "management (none) cluster type not yet supported in Phase 1 MVP. " +
                "Supported types: kind, minikube"
            );
            default -> throw new IllegalArgumentException(
                String.format(
                    "Unsupported cluster type: '%s'. Phase 1 MVP supports: kind, minikube",
                    clusterType
                )
            );
        };
    }

    /**
     * Builds cluster name using convention: clu-{num}-{type}-{engine}.
     *
     * <p>Examples:
     * <ul>
     *   <li>module=m1, type=pt, engine=kind → "clu-m1-pt-kind"</li>
     *   <li>module=m7, type=exam-prep, engine=minikube → "clu-m7-exam-prep-minikube"</li>
     * </ul>
     *
     * @param module module info
     * @param clusterType cluster engine type
     * @return cluster name
     */
    private String buildClusterName(ModuleInfo module, ClusterType clusterType) {
        return String.format(
            "clu-%s-%s-%s",
            module.num(),
            module.type(),
            clusterType.name().toLowerCase(Locale.ROOT)
        );
    }
}
